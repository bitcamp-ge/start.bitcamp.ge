# რიცხვები

ჯავასკრიპტში რიცხვები "ორმაგი-სიზუსტის 64-ბიტიანი ფორმატით" არის წარმოდგენილი, ტექნიკურად ამ ენაში არ არსებობს არანაირი `integer` \(მთელი რიცხვი\) ტიპი, ამიტომ სიფრთხილე უნდა გამოიჩინოთ მათემატიკური ოპერაციების დროს:

```text
console.log(3/2); // 1.5, not 1
console.log(Math.floor(3/2)); //1
```

გამოდის რომ, მთელი რიცხვი ჯავასკრიპტში - ათწილადია.

ასევე, ყურადღება მიაქციეთ შემდეგ მაგალIთსაც:

```text
0.1 + 0.2 == 0.30000000000000004;
```

პრაქტიკულად მთელი რიცხვები განიხილება როგორც `32-bit int` ტიპება და ასევე ძირითადად ასეცაა შენახული სანამ ისეთი ოპერაციების განხორცილება არაა საჭირო, რომლებიც უშუალოდ რიცხვებზე სრულდება და არა `32-bit integer` ტიპის ცვლადებზე.

ჯავასკრიპტის მხარდაჭერა მოიცავს სტანდარტულ არითმეტიკულ ოპერატორებს, მაგალითად: მიმატება, გამოკლება, მოდულუსი და ა.შ. ასევე არსებობს ჩაშენებული `Math` ობიექტებიც რომლებიც შედარებით მაღალი დონის ოპერაციებს: ფუნქციებს და კონსტანტებს გვთავაზობს, მაგალითად:

```text
Math.sin(3.5);
var circumference = 2 * Math.PI * r;
```

თქვენ შეგიძლიათ მათი კონვერტაცია `string` ან `integer` ტიპებში `parseInt()` ფუნქციით, რომელიც ასევე იღებს გარდაქმნის "საფუძველს" მეორე, ნებაყოფლობით არგუმენტს რომლეიც რეკომენდირებულია რომ აუცილებლად მოაყოლოთ:

```text
parseInt('123', 10) // 123
parseInt('010', 10) // 10
```

ასევე შეიძლება ბინარული/ორობითის მთელ რიცხვებში კონვერტაციაც:

```text
parseInt('11', 2); //3
```

ამის მსგავსად, შეგვიძლია იგივე ოპერაცია განვახორციელოთ ათწილადებზე, ასევე ჩაშენებული `parseFloat()` ფუნქციით, მაგრამ ამ შემთხევაში საფუძვლად იგი მუდმივად 10\_ს იყენებს და მისი მითითება საჭირო აღარ არის.

`+` ოპეარტორსაც შეუძლია სტრინგების რიცხვებში გარდაქმნა:

```text
+ '42' // 42
```

იმ შემთხვევაში თუ კონვერტაციისთვის მითითებული სტრინგი არ არის რიცხვითი, მაშინ მიიღებთ სპეციალური მნიშვნელობა `NaN`\_ს \(Not a Number\)

```text
parseInt('hello', 10); //NaN
```

`NaN` ტოქსიკურია, იმ შემთხევაში თუ მიუმატებთ, გამოაკლებთ ან რაიმე სახის მათემატიკურ ოპერაციას ჩაატარებთ სხვა რიცხვთან ერთად, პასუხი მუდმივად `NaN` იქნება:

```text
NaN + 5; //NაN
```

`NaN`\_ის შემოწმება შეიძლება ჩაშენებული `isNaN()` ფუნქციით:

```text
isNaN(NaN); // true
```

ჯავასკრიპტში ასევე შევხვდებით უსასრულობის ამღნიშვნელსაც `Infinity`:

```text
1 / 0; // Infinity
-1 / 0; // -Infinity
```

_`ParseInt() და parseFloat()` ფუნქციები ამოწმებენ სტრინგს სანამ არ მაიღწევენ ისეთ სიმბოლომდე რომელიც არ არის რიცხვითი მნიშვნელობის და ამ რიცხვამდე დააბრუნებენ ყველა რიცხვით მნიშვნელობას ათწილად ფორმატში მაგრამ + ოპერატორი ასეთ შემთხვევაში მხოლოდ `NaN`\_ს განახებთ._

