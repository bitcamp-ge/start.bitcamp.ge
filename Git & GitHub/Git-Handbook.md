# რა არის ვერსიების სამართავი სისტემა?

ვერსიების სამართავი სისტემა (Version Control System ან VCS შემოკლებით) ამონიტორინგებს ცვლილებებს და ინახავს მის ისტორიას. დეველოპერებს ეძლევათ საშუალება გადაამოწმონ ისტორია შემდეგი მიზნებისთვის:

* რა სახის ცვლილებები იქნა შეტანილი?

* ვინ შეიტანა ზემოხსენებული ცვლილებები?

* როდის მოხდა ცვლილების ასახვა?

* რატომ გახდა ცვლილებები საჭირო?

# რა არის განაწილებული ვერსიების სამართავი სისტემა?

Git არის მაგალითი განაწილებული ვერსიების სამართავი სისტემის. (Distributed Version Control System, ან DVCS შემოკლებით) ძირითადად გამოიყენება open source და კომერციულ software development-ში. DVCS გვაძლევს სრულ წვდომას თითოეულ ფაილზე, ბრენჩსა და პროექტის იტერაციაზე. სხვა პოპულარული ცენტრალიზებული ვერსიების სამართავი სისტემებისაგან განსხვავებით, DVCS-ები (მსგავსად Git-ისა) არ საჭიროებენ მუდმივ კავშირს ცენტრალურ რეპოზიტორიასან. დეველოპერებს შეუძლიათ იმუშაონ ნებისმიერი წერტილიდან და ითანამშრომლონ ასინქრონულად ნებისმიერი დროის ზონიდან.


# რატომ Git?

ბოლო [Stack Overflow developer survey](https://insights.stackoverflow.com/survey/2017#technology)-ზე დაყრდნობით 70%-ზე მეტი დეველოპერი იყენებს Git, რაც გულისხმობს იმას, რომ Git არის ყველაზე ფართოდ გამოყენებული VCS მსოფლიოში. Git ფართოდ გამოიყენება როგორც open source, ასევე კომერციულ software development-ში.
Git-ს აქვს **მნიშვნელოვანი ბენეფიტები** როგორც ინდივიდუალური პირებისთვის, ასევე გუნდებისა და ბიზნესისთვისაც.

* Git მეშვეობით დეველოპერებს საშუალება ეძლევათ ნახონ ცვლილებების მთლიანი ისტორიები, გადაწყვეტილებები და პროგრესი ნებისმიერი პროექტის ერთ სივრცეში.

* დეველოპერებს შეუძლიათ იმუშაონ დროის ნებისმიერი ზონიდან. ისეთი DVCS, როგორიც არის Git გაძლევთ კოლაბორაციის საშუალებას maintaining source code გაგების შეფერხების გარეშე.

* კომპანიები იყენებენ Git-ს რათა მოსპონ საკომუნიკაციო ბარიერები გუნდებს შორის და უზრუნველყონ მათი ფოკუსირება უფრო მეტად.


# რა არის სათავსო/საცავი (Repository)?

Repository, ანუ Git პროექტი, როგორც გარსი, ისე არის შემოხვეული პროექტში არსებულ ფაილებსა და ფოლდერებს. ფაილების ისტორიები წარმოჩენილია როგორც snapshot, რომელიც *commit*-ად არის ცნობილი, ხოლო ეს კომიტები არსებობენ როგორც linked-list კავშირი, რომლის დაყოფაც შესაძლებელია სხვადასხვა development გარემოებებად. ე.წ. ბრენჩები.

იქიდან გამომდინარე, რომ Git არის DVCS, რეპოზიტორები არიან დამოუკიდებელი ერტეულები და ნებისმიერი, ვინც ფლობს რეპოზიტორის ეგზემპლარს აქვს წვდომა მთლიან კოდთან და მასთან დაკავშირებულ ისტორიასთან. ბრძანებათა ხაზის ან სხვა ინტერფეისის საშუალებით git რეპოზიტორია ასევე საშუალებას გვაძლევს: დავკლონოთ, შევქმნათ ბრენჩები, დავაკომიტოთ, დავმერჯოთ და სხვ.

რეპოზიტორიებთან მუშაობით პროექტები არის უფრო ორგანიზებული და დაცული. დეველოპერები უფრო თამამად "ფიქსავენ ბაგებს", ან ქმნიან ახალ ცვლილებებს და არ არსებობს შიში იმისა, რომ მათი მთავარი პროდუქტი ჩამოინგრევა.


# საბაზისო Git ბრძანებები.

 Git გამოსაყენებლად, დეველოპერები იყენებენ სპეციალურ ბრძანებებს რომ დააკოპირონ, შექმნან, შეცვალონ ან შეაერთონ კოდი. ბრძანებების გაშვება შესაძლებელია პირდაპირ ბრძანებათა ხაზიდან (command line), ან აპლიკაციის გამოყენებით ([GitHub Desktop](https://desktop.github.com/) ან Git Kraken). ქვემოთ არის ჩამოთვლილი ხშირად გამოყენებული ბრძანებები Git გამოსაყენებლად:

* `git init` ინიციალიზებას ახდენს სრულად ახალი Git რეპოზიტორიისა და იწყებს თვალყურის დევნას არსებული დირექტორიისა. Git ამატებს დამალულ ქვე-ფოლდერს არსებულ დირექტორიაში, რომელშიც ინახება შიდა ინფორმაციული მონაცემთა სტრუქტურები, რომლებიც საჭიროა ვერსიების სამართავად.

* `git clone` ქმნის ლოკალურ ეგზემპლარს პროექტისა, რომელიც უკვე არსებობს დისტანციურად. კლონი მოიცავს პროექტის ყველა ფაილს, ისტორიასა და ბრენჩებს.

* `git add` ამატებს ცვლილებას. ვინაიდან Git ამონიტორინგებს დეველოპერის კოდში შეტანილ ცვლილებებს, მნიშვნელოვანია, რომ დავამატოთ ცვლილებები, რათა მოხდეს მათი ასახვა პროექტის ისტორიაში. ზემოხსენებული ბრძანება პასუხისმგებელია დამატებაზე (რომელიც შეგვიძლია მოვიხენიოთ პირველ ეტაპად, რადგანაც სულ 2 ეტაპიანია ეს პროცესი). ნებისმიერი ცვლილება, რომელიც არის დამატებული იქნება პროექტის ისტორიის ნაწილი. 

* `git commit` ასეივებს/ინახავს დამატებულ ცვლილებას/სნეფშოტს პროექტის ისტორიაში და ამით სრულდება ცვლილებების მონიტორინგის პროცესი. მოკლედ რომ ვთქვათ, კომიტ ბრძანება გავს სურათის გადაღებას. ნებისმიერი ცვლილება, რომელიც დამატებულია `git add` ბრძანებით, შენახული/დაკომიტებებული იქნება `git commit` მიერ.

* `git status` გვიჩვენებს ცვლილებების სტატუსს, რომლებიც არიან  `untracked, modified, staged` სტადიებში.

* `git branch` გვიჩვენებს ლოკალურად არსებულ ბრენჩებს.

* `git merge` ძირითადად ეს ბრძანება გამოიყენება მაშინ, როდესაც სურთ ორი განსხვავებული ბრენჩის შეერთება. მაგალითისთვის: დეველოპერი გამოიყენებს ამ ბრძანებას როდესაც მათ სურთ ცვლილებების ასახვა *feature branch*-დან მთავარ *(master/main)* ბრენჩში.

* `git pull` ანახლებს დეველოპმენტის ლოკალურ ხაზს დისტანციური(*remote*) ნაწილიდან გამომდინარე.მაგალითისთვის: X დეველოპერი გამოიყენებს ამ ბრძანებას, თუ Y დეველოპერმა განაახლა დისტანციური(remote) ბრენჩი და X დეველოპერს სურს დისტანციურ ბრენჩზე არსებული ცვლილებების ლოკალურად წამოღება(განახლება).

* `git push` ანახლებს დისტანციურ(remote) ბრენჩს ყველა იმ კომიტით, რაც გვაქვს ლოკალურ ბრენჩში.

თუ გსურთ უფრო დეტალური განმარტებები, ან გსურთ ყველა git ბრძანებების ხილვა, ეწვიეთ: [a full reference guide to Git Commands.](https://git-scm.com/docs)

# აღმოაჩინე უფრო მეტი Git ბრძანებები

უფრო დეტალური განხილვისთვის (თავისი პრაქტიკული მაგალითებით) დაგეხმარებათ შემდეგი რესურსები:

* [Working locally](https://www.youtube.com/watch?v=rBbbOouhI-s&index=2&list=PLg7s6cbtAD17Gw5u8644bgKhgRLiJXdX4)
* [`git status`](https://www.youtube.com/watch?v=rBbbOouhI-s&index=2&list=PLg7s6cbtAD17Gw5u8644bgKhgRLiJXdX4)
* [Two-step commits](https://www.youtube.com/watch?v=Vb0Ghkkc2hk&index=4&list=PLg7s6cbtAD17Gw5u8644bgKhgRLiJXdX4)
* [`git pull` and `git push`](https://www.youtube.com/watch?v=-uQHV9GOA0w&index=5&list=PLg7s6cbtAD17Gw5u8644bgKhgRLiJXdX4)


# როგორ გვეხმარება GitHub

GitHub არის Git დასაჰოსტი რეპოზიტორია, რომელიც დეველოპერებს უზრუნველყოფს ხელსაწყოებით უკეთესი კოდის ხარისხისათვის, pull request-ებისათვის, კოდის განხილვისათვის და ასევე გვაწვდის უამრავ უფასო, ან შესყიდვად აპლიკაციებს, რომლებიც ხელმისაწვდომია GitHub Marketplace-ში. 

# როგორ მუშაობს GitHub

GitHub-ი დეველოპმენტის პროცესში ქმნის კოლაბორაციას. შესასრულებელი სამუშაო არის ორგანიზებული რეპოზიტორიებში, სადაც დეველოპერებს ხაზგასმით შეუძლიათ ჩამოაყალიბონ მიმართულებები და მოლოდინები თითოეული გუნდის წევრისათვის. შემდგომ, GitHub flow-ის გამოყენებით, დეველოპერები ქმნიან ბრენჩებს, რათა იმუშაონ განახლებებზე, დააკომიტონ ცვლილებები, გახსნან pull request-ები, რათა მოხდეს შეტანილი ცვლილებების განხილვა და შემდგომ მათი ასახვა.

# GitHub flow

GitHub flow არის მსუბუქი, ბრენჩზე დაფუძნებული workflow, რომელიც დაშენებულია `core git commands`-ზე.

GitHub flow შედგება 6 ნაბიჯისაგან, რომლებიც ერთმანეთის დამოუკიდებლად ქმნიან ბენეფიტებს, როდესაც ხდება მათი იმპლემენტაცია:

1. **შექმენი ბრენჩი:** თემატური ბრენჩები, რომლებიც ძირითად შემთხვევებში იქმნება ბრენჩ `master/main`-დან, გუნდებს აძლევს საშუალებას, რომ შეიტანონ წვლილი პარალელურად ერთმანეთთან კონფლიქტის გარეშე.

2. **დაამატე კომიტები:** კომიტების მეშვეობით იქმნება უკან დაბრუნებადი "წერტილები", რომლებიც ისახება პროექტის ისტორიაში და ხარვეზის დროს ბევრად მარტივი და უსაფრთხოა უსაფრთხო გარემოს აღდგენა.

3. **გახსენი pull request-ები:** pull request-ებით დეველოპმენტის პროცესი ხდება გამჭირვალე, რაც გულისხმობს იმას, რომ ყველას ეძლევა შესაძლებლობა განიხილოს თქვენ მიერ შეტანილი ცვლილებები, გაიმართოს დისკუსია, მოგცენ უკეთესი რჩევები და ამის შემდგომ მოხდეს თქვენი ცვლილებების შერწყმა.

4. **ჩაერთეთ და განიხილეთ კოდი:** ძირითად შემთხვევებში გუნდები მონაწილეობას იღებენ კოდის განხილვაში (ე.წ. code review process) დაკომენტარებით, გატესტვით, ან უბრალოთ თქვენი კოდის განხილვით. code review არის ფუნდამენტი დეველოპმენტ პროცესში.

5. **შერწყმა(Merge):** ღილაკ `merge`-ზე დაჭერით, GitHub ავტომატურად ასრულებს  `git merge` ოპერაციას. GitHub აგრეთვე ინახავს მთლიანი ბრენჩის დეველოპმენტ ისტორიას.

6. **Deploy:** გუნდებს შეუძლიათ ამოირჩიონ საუკეთესო დასარილიზებელი ციკლები, ან დააიმპლემენტირონ `continuous integration tools`, რათა დარწმუნდნენ, რომ კოდი, რომელიც არსებობს deployment ბრენჩზე წარმატებით გაიარა robust worfklow-ი.


# გაიგე მეტი GitHub flow-ზე

დამატებითი რესურსებისთვის, შეგიძლიათ ეწვიოთ:

* [Interactive guide](https://guides.github.com/introduction/flow/)
* [GitHub Flow video](https://www.youtube.com/watch?v=47E-jcuQz5c&index=1&list=PLg7s6cbtAD17Gw5u8644bgKhgRLiJXdX4)


# GitHub და ბრძანებათა ხაზი (command line)

მათთვის, ვინც არიან ახლები command line-ში, ვთვლი, რომ ქვემოთ მოყვანილი მაგალითები დაგეხმარებათ უკეთ წარმოიდგინოთ, თუ როგორ გამოიყენოთ Git:

# მაგალითი: შეიტანეთ ცვლილებები არსებულ რეპოზიტორიში

```
# გადმოწერე/დაკლონე  რეპოზიტორია Github.com-დან  თქვენს კომპიუტერში
git clone https://github.com/me/repo.git

# გადადით `repo` დირექტორიაში
cd repo

# შექმენით ახალი ბრენჩი
git branch my-branch

# გადადით შექმნილ ბრენჩზე (დეველოპმენტის ახხალ ხაზზე)
git checkout my-branch

# შეიტანეთ ცვლილებები, მაგ:   შეიტანეთ ცვლილებები `file1.md` და `file2.md`-ში

# დაამატეთ  ფაილები
git add file1.md file2.md

# დააკომიტეთ/დაასეივეთ შეტანილი ცვლილებები. (`-m`) არგუმენტი გამოიყენება კომენტარის დასართავად.
git commit -m "my snapshot"

# დაფუშეთ ცვლილებები github-ზე
git push --set-upstream origin my-branch
```

# მაგალითი: ახალი რეპოზიტორიის შექმნა და ასახვა GitHub-ზე

პირველ რიგში საჭიროა, რომ შექმნათ ახალი რეპოზიტორია. შეგიძლიათ გაეცნოთ ჩვენს [Hello World](../Hello-world.md) გაკვეთილს. **არ** დააინიციალიზიროთ რეპოზიტორია README, .gitignore ან License ფაილებით.


```
# შექმენით ახალი დირექტორია და დააინიციალიზირეთ ის git სპეციფიური ფუნქციებით.
git init my-repo

# გადაინაცვლეთ `my-repo` დირექტორიაში
cd my-repo

# შექმენით პირველი ფაილი თქვენს პროექტში
touch README.md

# git-მა არ იცის შექმნილი ფაილის შესახებ, დაამატეთ ის.
git add README.md

# დააკომიტეთ/დაასეივეთ დამატებული ფაილი შესაბამისი მესიჯით.
git commit -m "add README to initial commit"

# მიაწოდეთ სრული მისამართი იმ რეპოზიტორიისა, რომელიც შექმენით github-ზე
git remote add origin https://github.com/YOUR-USERNAME/YOUR-REPOSITORY.git

# ასახეთ ცვლილებები github-ზე
git push --set-upstream origin main

```


# დამატებითი რესურსები

* [Beginner projects to explore](https://github.com/showcases/great-for-new-contributors)
* [GitHub video guides](https://youtube.com/githubguides)
* [GitHub on-demand training](https://lab.github.com/)
* [GitHub training guides](https://guides.github.com/)
* [GitHub training resources](https://lab.github.com/)

